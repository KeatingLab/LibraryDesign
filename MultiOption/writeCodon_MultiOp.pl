## writeCodon_MultiOp.pl
# adapted from writeCodon.pl written by T. Scott Chen, Keating Lab, MIT.

# Modified January 2014 by Daniel Richman, Keating Lab, MIT. 
# Purpose: this file reads in lists of amino acids we would like to include at positions in the peptide
# Then we generate degenerate codons encoding combos of those AAs for selection by the ILP solver. 

# Parameters you can change:
# Chemical diversity classes (favors inclusion of multiple types of AAs at certain residues in the ILP)
# Scoring mode: specificity score, MSA score, or a combination of both. 


########## Read stuff in. 
# read in a list of amino acids that need to be included at each designed site (required - sp)
my $nfile = shift;
# read in a file that contains score for each amino acid (preferred - nd)
my $efile = shift;
# read in MSA [multiple sequence alignment] file generated by analyzeMSA.py
my $mfile = shift;
# the output file
my $ofile = shift;

# read the codon file
my $codon_combo_file = 'codon_combos.txt';

# settings for chemical diversity classes - CHANGE THESE TO YOUR POSITION NAMES AND DIVERSITY SETS
my $R = {};
$R->{'E2a'} = [['I', 'V'], ['K', 'R'], ['E', 'D'], ['A', 'G', 'S', 'T'], ['N', 'Q']]; 
$R->{'A2e'} = [['D', 'N'], ['S', 'T'], ['G', 'A']];
$R->{'E2g'} = [['D', 'E'], ['K', 'R'], ['N', 'Q'], ['S', 'T'], ['G', 'A']];
$R->{'R3b'} = [['D', 'E'], ['K', 'R'], ['N', 'Q'], ['S', 'T'], ['G', 'A']];
$R->{'E3g'} = [['D', 'E'], ['K', 'R'], ['N', 'Q'], ['S', 'T'], ['G', 'A']];
$R->{'I2d'} = [['I', 'V'], ['A'], ['L'], ['F', 'Y']];
$R->{'L3a'} = [['I', 'V'], ['A'], ['L'], ['F', 'Y']];
$R->{'I3d'} = [['I', 'V'], ['A'], ['L'], ['F', 'Y']];
$R->{'L4a'} = [['I', 'V'], ['A'], ['L'], ['F', 'Y']];

# read in the codon combinations
my $C = {};
open (my $cfh, "<", $codon_combo_file) or die "Cannot open $codon_combo_file\n";
while (<$cfh>) {
  chomp;
  my @lines = split;
  $C->{$lines[0]}->{size} = trim($lines[1]); #codon size hash
  my $aa_str;
  my $count_hash = {};
  for (my $i = 2; $i < scalar(@lines); $i = $i + 2) {
    my $aa = trim($lines[$i]);
    $aa_str .= $aa;
    my $count = trim($lines[$i+1]);
    $count_hash->{$aa} = $count;
  }
  $C->{$lines[0]}->{str} = $aa_str;  #aas encoded by codon
  $C->{$lines[0]}->{count} = $count_hash;  #number of times each aa is encoded in codon
}
close($cfh);

# read in the file that contains information about essential amino acids at each site
open (my $nfh, "<", $nfile) or die "Cannot open $nfile\n";
my $N = {};
while (<$nfh>) {
  chomp;
  if (/^([A-Z][0-9]+[a-z]?) ([A-Z]+)/) {  #match position letter, number, and aa string
    my $site = $1;   #site=position name
    my $aa_str = $2;  #aa_str=required aa at that position
     
    my @aas = split "", $aa_str;
    foreach my $aa (@aas) {
      $N->{$site}->{$aa} = 1;  #$N holds required residues, by position (site)
    }
  }
}
close($nfh);

# read in the file that contains information about scores for point mutants 
open (my $efh, "<", $efile) or die "Cannot open $efile\n";
my $index = 0;
my $E = {};
my $site;
my $aa;
while (<$efh>) {
  chomp;
  if (/^([A-Z][0-9][a-z]?)/) {   #matches position name/number
    my $site = $1;
    my @lines = split;
    shift @lines;
    for (my $i = 0; $i < scalar(@lines); $i = $i + 2) {
      my $aa = $lines[$i];   #get preferred aa
      my $score = $lines[$i+1];  #get 'score' (0 or 1) for that aa
      $E->{$site}->{$aa} = $score;  #$E holds scores for preferred aa, organized by position
    } 
  }
}
close($efh);

# read in csv file (e.g. of frequencies from an MSA)
# Note: we reuse $index, $site, and $aa from above. But the values are not the same. 
open (my $mfh, "<", $mfile) or die "Cannot open $mfile\n";
$index = 0;
my $M = {};

my $msa_firstline = <$mfh>;
my @msa_sites = split ",", $msa_firstline;

while (<$mfh>) {
  chomp;
  
  my @aa_scores = split ",";
  my $aa = $aa_scores[0];
  
  for my $i (1..$#aa_scores) {
    my $msa_site = $msa_sites[$i]; # get location
    my $score = $aa_scores[$i]; # get MSA score of this aa at this location
        
	$M->{$msa_site}->{$aa} = $score;	#$E holds scores for preferred aa, organized by position
  } 

}
close($mfh);

############## Go through possible codons, compute various scores, write out ones we want the ILP solver to consider. 
open (my $ofh, ">", $ofile) or die "Cannot write into $ofile\n";

foreach my $site (sort resid_sort keys %$E) {    #sort position names
  printf $ofh "$site\n";

  my $sols = {};
  foreach my $cname (keys %$C) {  #cname = codon name
    my $aa_str = $C->{$cname}->{str};
    my $codon_size = $C->{$cname}->{size};  #number of trinucleotides
    my $count = $C->{$cname}->{count};   #number of times aa is encoded by codon
    my $include = 1;
    foreach my $aa (keys %{$N->{$site}}) {  #required aa
      if (!defined($count->{$aa})) {   #Only include codons that encode all required aa
        $include = 0;
        last; # break out of loop
      }
    }
    if ($include == 0) {
      next;
    }

    my $score = 0.0;   #score = number of preferred (non-disrputive) aa
    my $useful_size = 0.0;  #number of trinucleotides encoding preferred aa

    foreach my $aa (keys %{$E->{$site}}) {  #preferred residues
      if (defined($count->{$aa})) {   #if $aa is encoded by this codon
        $score += $E->{$site}->{$aa};    #add score for preferred residue (0 or 1)
        if ($E->{$site}->{$aa} > 0) {  #if residue is non-disruptive (preferred) (score is 1)   
          $useful_size += $count->{$aa};   #add number of times aa is encoded by codon
        }  
      }
    }
    
    # calculate MSA score for this codon. We add up the MSA frequencies for each aa encoded by the codon. 
    my $msa_score = 0.0;
    foreach my $aa (keys %{$count}) {
      $msa_site = substr $site, 1; # if $site is "E2a", the corresponding site in the MSA array will be "2a" since by definition there is no one wt in MSA. 
      
      if (defined($M->{$msa_site}->{$aa})) {
        $msa_score += $M->{$msa_site}->{$aa};
      }
    }
    
    # calculate chemical diversity score for this codon
    my $classes_missed = 0;
    
    if (defined $R->{$site}) { # if this site has diversity criteria
      my $aa_classes = $R->{$site};
      my $classes_included = 0;
      
      foreach my $aa_class (@$aa_classes) {
      my $class_included = 0;
          
          foreach my $aa (@$aa_class) {
            if (defined($count->{$aa})) {
              $class_included = 1;
              last;
            }
          }
          
          if ($class_included == 1) {
            $classes_included++;
          }
      
      }
      
      $classes_missed = scalar @{$R->{$site}} - $classes_included;
    }
    
    #$sols holds codons that (meet criteria?)
    $sols->{$cname}->{perc} = $useful_size / $codon_size;  #percent of codons encoding preferred aa
    $sols->{$cname}->{codon} = $cname; #codon name
    $sols->{$cname}->{size} = $codon_size;  #number of trinucleotides encoded
    $sols->{$cname}->{aa_str} = $aa_str;  #list of aa encoded
    $sols->{$cname}->{score} = $score;  #number of preferred aa encoded
    $sols->{$cname}->{msa_score} = $msa_score; # codon MSA score
    $sols->{$cname}->{trs} = $classes_missed; # trs = total required miss
  }

  # Build output. Each possible codon must be compared to all previously accepted codons. 
  my $PO = {};
  NEWSOL: # codon not yet in PO
  foreach my $codon1 (keys %$sols) {
    my $h1 = $sols->{$codon1};
    OLDSOL: # codon already in PO, but being compared to possible new codon
    foreach my $codon2 (keys %$PO) {
      my $h2 = $sols->{$codon2};
      if (($h1->{aa_str} eq $h2->{aa_str}) and ($h1->{size} > $h2->{size})) {
        next NEWSOL; #if two codons encode the same aas and codon1 has more trincleotides, then do not include codon1
      }

      if (($h1->{size} == $h2->{size}) and ($h1->{score} == $h2->{score})) { #if codon size and number of preferred residues are equal for two codons
        if ($h1->{aa_str} =~ /Z/ and $h2->{aa_str} !~ /Z/) {  #if codon1 includes a stop codon and codon2 doesn't, then skip codon1
          next NEWSOL;
        } elsif ($h1->{aa_str} !~ /Z/ and $h2->{aa_str} =~ /Z/) { #if codon1 doesn't include a stop codon and codon2 does, then delete codon2 and add codon1 to list
          delete $PO->{$codon2};
          next OLDSOL;
        }
      } elsif (($h1->{size} >= $h2->{size}) and ($h1->{score} <= $h2->{score}) and ($h1->{msa_score} <= $h2->{msa_score}) and ($h1->{trs} >= $h2->{trs})) { #if codon1 size is larger than codon2 and codon1 score is smaller and codon1 misses more chem diversity classes
        next NEWSOL;  #then do not include codon1
      } elsif (($h1->{size} <= $h2->{size}) and ($h1->{score} >= $h2->{score}) and ($h1->{msa_score} >= $h2->{msa_score}) and ($h1->{trs} <= $h2->{trs})) { #if codon1 is smaller than codon2 and codon1 has a larger score and codon2 misses more chem diversity classes
        delete $PO->{$codon2};  #then remove codon2
        next OLDSOL;
      }

    }
    $PO->{$codon1} = 1;
  }

  foreach my $c_name (keys %$PO) {   #Print output to output file
    printf $ofh "%s %s %s %.2f %.2f %d %.2f\n", $c_name, $C->{$c_name}->{str}, $sols->{$c_name}->{size}, $sols->{$c_name}->{score}, $sols->{$c_name}->{msa_score}, $sols->{$c_name}->{trs}, $sols->{$c_name}->{perc};
  }  
}

close($ofh);

sub resid_sort {   #Position sorting function: sort by position number. Commented out code sorts by wt AA name. 
#    $chain_a = substr $a, 0, 1;
    $res_a = substr $a, 1;
#    $chain_b = substr $b, 0, 1;
    $res_b = substr $b, 1;

#    $chain_a cmp $chain_b
#      ||
    $res_a cmp $res_b
}

sub trim {   #line trimming function
   my $string = shift;
   $string =~ s/^\s+//;
   $string =~ s/\s+$//;
   return $string;
}    

